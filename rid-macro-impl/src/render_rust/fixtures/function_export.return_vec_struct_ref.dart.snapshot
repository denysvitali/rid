 extension Rid_Vec_ExtOnPointerRidVec_Pointer_MyStruct on ffigen_bind.RidVec_Pointer_MyStruct {
   dart_ffi.Pointer<ffigen_bind.MyStruct> operator [](int idx) {
     final len = this.length;
     if (!(0 <= idx && idx < len)) {
       throw AssertionError("Out of range access on List<dart_ffi.Pointer<ffigen_bind.MyStruct>>[$idx] of length $len");
     }
     return rid_ffi.rid_get_item_Pointer_MyStruct(this, idx);
   }

   void dispose() {
     rid_ffi.rid_free_vec_Pointer_MyStruct(this);
   }

   Rid_RidVec_Pointer_MyStruct_Iterable iter() => Rid_RidVec_Pointer_MyStruct_Iterable(this);
 }

 class Rid_RidVec_Pointer_MyStruct_Iterator implements Iterator<dart_ffi.Pointer<ffigen_bind.MyStruct>> {
   int _currentIdx = -1;
   final ffigen_bind.RidVec_Pointer_MyStruct _vec;
   final int _limit;

   Rid_RidVec_Pointer_MyStruct_Iterator(this._vec) : _limit = _vec.length - 1;

   dart_ffi.Pointer<ffigen_bind.MyStruct> get current => _vec[_currentIdx];

   bool moveNext() {
     if (_currentIdx >= _limit) return false;
     _currentIdx++;
     return true;
   }
 }

 class Rid_RidVec_Pointer_MyStruct_Iterable with
     dart_collection.IterableMixin<dart_ffi.Pointer<ffigen_bind.MyStruct>> {
   final ffigen_bind.RidVec_Pointer_MyStruct _vec;
   Rid_RidVec_Pointer_MyStruct_Iterable(this._vec);

   Iterator<dart_ffi.Pointer<ffigen_bind.MyStruct>> get iterator =>
     Rid_RidVec_Pointer_MyStruct_Iterator(this._vec);
 }
