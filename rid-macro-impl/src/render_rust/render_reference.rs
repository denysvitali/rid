use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use syn::Ident;

use crate::parse::ParsedReference;

const POINTER_ALIAS_PREFIX: &str = "Pointer_";
const POINTER_MUT_ALIAS_PREFIX: &str = "PointerMut_";

/// Types like `*const X` and `*mut X` are aliased in order to avoid confusing and
/// non-deterministic names being generated by bindgen when they're used as generic types, for
/// instance in `RidVec<T>`.
/// For example `*const Item` is aliased to `Pointer_Item` which then results in
/// `RidVec_Pointer_Item` instead of something like `RidVec______Item`.
#[derive(Debug, Clone)]
pub struct TypeAlias {
    pub alias: Ident,
    pub typedef: TokenStream,
}

impl ParsedReference {
    pub fn stringify_lifetime(&self) -> String {
        match self.lifetime() {
            Some(lifetime) => format!("'{}", lifetime),
            None => "".to_string(),
        }
    }

    pub fn render(&self) -> TokenStream {
        match self {
            ParsedReference::Owned => TokenStream::new(),
            ParsedReference::Ref(lifetime) => {
                let lifetime_toks = render_lifetime(lifetime.as_ref());
                quote! { &#lifetime_toks }
            }
            ParsedReference::RefMut(lifetime) => {
                let lifetime_toks = render_lifetime(lifetime.as_ref());
                quote! { &#lifetime_toks mut }
            }
        }
    }

    pub fn render_pointer(
        &self,
        type_name: &str,
    ) -> (Option<TypeAlias>, TokenStream) {
        let name_tok: TokenStream = type_name.parse().unwrap();
        match self {
            ParsedReference::Owned => (None, name_tok),
            ParsedReference::Ref(_) => {
                let alias =
                    format_ident!("{}{}", POINTER_ALIAS_PREFIX, type_name);
                let typedef = quote! { type #alias = *const #name_tok; };
                (
                    Some(TypeAlias {
                        alias: alias.clone(),
                        typedef,
                    }),
                    quote! { #alias },
                )
            }
            ParsedReference::RefMut(_) => {
                let alias =
                    format_ident!("{}{}", POINTER_MUT_ALIAS_PREFIX, type_name);
                let typedef = quote! { type #alias = *mut #name_tok };
                (
                    Some(TypeAlias {
                        alias: alias.clone(),
                        typedef,
                    }),
                    quote! { #alias },
                )
            }
        }
    }

    pub fn render_deref(&self) -> TokenStream {
        match self {
            ParsedReference::Owned => TokenStream::new(),
            ParsedReference::Ref(_) => quote! { .as_ref() },
            ParsedReference::RefMut(_) => quote! { .as_mut() },
        }
    }

    pub fn is_owned(&self) -> bool {
        match self {
            ParsedReference::Owned => true,
            ParsedReference::Ref(_) | ParsedReference::RefMut(_) => false,
        }
    }
}

pub fn render_lifetime(lifetime: Option<&syn::Ident>) -> TokenStream {
    match lifetime {
        Some(lifetime) => format!("'{}", lifetime).parse().unwrap(),
        None => TokenStream::new(),
    }
}

pub fn render_lifetime_def(lifetime: Option<&syn::Ident>) -> TokenStream {
    match lifetime {
        Some(lt) => {
            let lt: TokenStream = format!("'{}", lt).parse().unwrap();
            quote! { <#lt> }
        }
        None => TokenStream::new(),
    }
}
