#![feature(str_split_once)]

use std::{fs, path::Path};

use anyhow::Result;

use bindings_generator::BindingsGenerator;
use dart_generator::{BuildTarget, DartGenerator};
use project::Project;
mod bindings_generator;
mod dart_generator;
mod project;

pub struct BuildConfig<'a> {
    pub project_root: &'a str,
    pub lib_name: &'a str,
    pub crate_name: &'a str,
    pub project: Project,
    pub target: BuildTarget,
}

/// Result of generating C header file via cbindgen as well as the Dart derived from it.
/// The header file is written as a side effect. For Flutter it is placed inside the `ios/Classes`
/// folder where it is needed, for Dart it is placed in a temp folder to be forgotten.
/// The generated Dart and the path to where it should be placed is the only information actually
/// included in this result.
#[derive(Debug)]
struct GenerateResult {
    /// Content of Dart generated and to be included by the Dart or Flutter app.
    generated_dart: String,

    /// Path at which the Dart/Flutter app expects the generated Dart code to be and from which the
    /// generated code imports the darg ffigen generated bindings.
    generated_dart_path: String,

    /// Path at which the C headers file was written. This may be ignored for Dart apps, but should
    /// be located in the correct location for Flutter apps.
    generated_bindings_h_path: String,
}

fn generate(
    BuildConfig {
        project_root,
        lib_name,
        crate_name,
        project,
        target,
    }: &BuildConfig,
) -> Result<GenerateResult> {
    let bindings_generator = BindingsGenerator {
        crate_name,
        crate_dir: project_root,
        cargo: "cargo",
    };
    let project_root = Path::new(project_root);
    let bindings_h = bindings_generator.generate()?;
    let bindings_h_path = project.path_to_generated_bindings(project_root, crate_name);

    // TODO: cbindgen unwraps all over the place here, so we should ensure that we can
    // access the file we're writing to
    // NOTE: as a side effect we write the binding.h file here already, it goes unused for Dart,
    // but is essential for Flutter ios apps.
    bindings_h.write_to_file(&bindings_h_path);

    let bindings_h_content = fs::read_to_string(&bindings_h_path)?;

    // NOTE: this is generated by dart ffigen step which we don't corrently control
    let ffigen_generated_path = project.path_to_generated_ffigen(project_root);
    let generated_dart_path = project.path_to_generated_rid(project_root);

    // TODO: determine this as relative path from  'generated_dart_path' -> 'ffigen_generated_path'
    let ffigen_binding = &format!(
        "./{}",
        ffigen_generated_path.file_name().unwrap().to_string_lossy()
    );
    let path_to_target = &format!("{}", project.path_to_target(project_root).display());

    let dart_generator = DartGenerator {
        lib_name,
        target,
        ffigen_binding,
        path_to_target,
        binding: &bindings_h_content,
    };

    let generated_dart = dart_generator.generate();

    Ok(GenerateResult {
        generated_dart,
        generated_dart_path: format!("{}", generated_dart_path.display()),
        generated_bindings_h_path: format!("{}", bindings_h_path.display()),
    })
}

pub fn build(build_config: &BuildConfig) -> Result<()> {
    let GenerateResult {
        generated_dart,
        generated_dart_path,
        ..
    } = generate(build_config)?;

    // TODO: ensure that the directory to which we write exists and is accessible
    fs::write(generated_dart_path, generated_dart)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generate_test() {
        // NOTE: the lib folder doesn't actually exist for this fixture, however since for Dart
        // apps the binding.h file is written to a tmp folder that doesn't matter.

        let build_config = BuildConfig {
            project_root: "fixtures/foo-bar-baz",
            project: Project::Dart,
            lib_name: "libfoo_bar_baz",
            crate_name: "foo_bar_baz",
            target: BuildTarget::Debug,
        };
        let result = generate(&build_config);
        match result {
            Err(err) => assert!(false, format!("generate should not error {}", err)),
            Ok(result) => println!("{:#?}", result),
        };
    }
}
