#![allow(stable_features)]
#![feature(str_split_once)]
use std::{fmt::Display, fs, path::Path};

use anyhow::Result;

use bindings_generator::BindingsGenerator;
use dart_generator::DartGenerator;

mod bindings_generator;
mod code_sections;
mod dart_generator;
mod log;
mod project;
mod swift_injector;

pub use dart_generator::BuildTarget;
pub use project::{FlutterConfig, FlutterPlatform, Project};

use crate::{code_sections::CodeSections, swift_injector::SwiftInjector};

pub struct BuildConfig<'a> {
    pub project_root: &'a str,
    pub workspace_root: Option<&'a str>,
    pub lib_name: &'a str,
    pub crate_name: &'a str,
    pub project: Project,
    pub target: BuildTarget,
}

/// Result of generating C header file via cbindgen as well as the Dart derived from it.
/// The header file is written as a side effect. For Flutter it is placed inside the `ios/Classes`
/// folder where it is needed, for Dart it is placed alongside the generated dart for now.
/// The generated Dart and the path to where it should be placed is included as well.
#[derive(Debug)]
pub struct BuildResult {
    /// Content of Dart generated and to be included by the Dart or Flutter app.
    generated_dart: String,

    /// Path at which the Dart/Flutter app expects the generated Dart code to be and from which the
    /// generated code imports the darg ffigen generated bindings.
    /// This file still needs to be written.
    generated_dart_path: String,

    /// Path at which the C headers file was ALREADY written. This may be ignored for Dart apps,
    /// but should be located in the correct location for Flutter apps.
    generated_bindings_h_path: String,

    /// Swift plugin files that were modified in ordert to prevent Rust functions from being
    /// removed via tree shaking.
    swift_plugin_files: Vec<String>,
}

impl Display for BuildResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "
Rid Build Result
================
Path to generated bindings: {generated_bindings_h_path}
Path to generated Dart:     {generated_dart_path}
Paths to modified Swift:    [{swift_plugin_files}]
",
            generated_bindings_h_path = self.generated_bindings_h_path,
            generated_dart_path = self.generated_dart_path,
            swift_plugin_files = self.swift_plugin_files.join(", "),
        )
    }
}

fn generate(
    BuildConfig {
        project_root,
        workspace_root,
        lib_name,
        crate_name,
        project,
        target,
    }: &BuildConfig,
) -> Result<BuildResult> {
    let bindings_generator = BindingsGenerator {
        crate_name,
        crate_dir: project_root,
        cargo: "cargo",
    };
    let target_crate_root = Path::new(workspace_root.unwrap_or(project_root));
    let project_root = Path::new(project_root);
    log::info!("Generating bindings");

    let bindings_h = bindings_generator.generate()?;
    let bindings_h_paths = project.paths_to_generated_c_bindings(project_root);

    // TODO: cbindgen unwraps all over the place here, so we should ensure that we can
    // access the file we're writing to
    // NOTE: as a side effect we write the binding.h file here already, it goes unused for Dart,
    // but is essential for Flutter ios apps.
    for bindings_h_path in &bindings_h_paths {
        bindings_h.write_to_file(&bindings_h_path);
    }
    let bindings_h_path = &bindings_h_paths[0];
    let bindings_h_content = fs::read_to_string(&bindings_h_path)?;

    // NOTE: this is generated by dart ffigen step which we don't corrently control
    let ffigen_generated_path = project.path_to_generated_ffigen(project_root);
    let generated_dart_path = project.path_to_generated_rid(project_root);

    // TODO: determine this as relative path from  'generated_dart_path' -> 'ffigen_generated_path'
    let ffigen_binding = &format!(
        "./{}",
        ffigen_generated_path.file_name().unwrap().to_string_lossy()
    );
    let path_to_target =
        &format!("{}", project.path_to_target(target_crate_root).display());

    // Extract Dart and Swift code from bindings.h
    let code_sections = CodeSections::new(&bindings_h_content);

    // Generate Dart glue code and add to code extracted from bindings.h
    log::info!("Generating Dart glue code");
    let dart_generator = DartGenerator {
        lib_name,
        target,
        ffigen_binding,
        path_to_target,
        code_sections: &code_sections,
        project: &project,
    };
    let generated_dart = dart_generator.generate();

    // Inject swift code to prevent tree shaking
    log::info!("Injecting Swift code into plugin");
    let swift_injector = SwiftInjector { project: &project };
    let swift_plugin_files = swift_injector
        .inject(&project_root, &code_sections.swift_code)?
        .into_iter()
        .map(|x| format!("{}", x.display()))
        .collect();

    Ok(BuildResult {
        generated_dart,
        generated_dart_path: format!("{}", generated_dart_path.display()),
        generated_bindings_h_path: format!("{}", bindings_h_path.display()),
        swift_plugin_files,
    })
}

pub fn build(build_config: &BuildConfig) -> Result<BuildResult> {
    log::init();

    let generate_result = generate(build_config)?;
    let BuildResult {
        generated_dart,
        generated_dart_path,
        ..
    } = &generate_result;

    // NOTE: the directory to hold the file is recursively created if it doesn't exist yet
    fs::write(generated_dart_path, generated_dart)?;

    Ok(generate_result)
}

// TODO: disabled due to getting stuck
#[cfg(test_disabled)]
mod tests {
    use super::*;

    #[test]
    fn generate_test() {
        let build_config = BuildConfig {
            project_root: "fixtures/foo-bar-baz",
            workspace_root: None,
            project: Project::Dart,
            lib_name: "libfoo_bar_baz",
            crate_name: "foo_bar_baz",
            target: BuildTarget::Debug,
        };
        let result = generate(&build_config);
        match result {
            Err(err) => assert!(false, "generate should not error {}", err),
            Ok(result) => println!("{:#?}", result),
        };
    }
}
