#![allow(stable_features)]
#![feature(str_split_once)]
use std::{fs, path::Path};

use anyhow::Result;

use bindings_generator::BindingsGenerator;
use dart_generator::DartGenerator;

mod bindings_generator;
mod code_sections;
mod dart_generator;
mod log;
mod project;

pub use dart_generator::BuildTarget;
pub use project::{FlutterConfig, FlutterPlatform, Project};

use crate::code_sections::CodeSections;

pub struct BuildConfig<'a> {
    pub project_root: &'a str,
    pub workspace_root: Option<&'a str>,
    pub lib_name: &'a str,
    pub crate_name: &'a str,
    pub project: Project,
    pub target: BuildTarget,
}

/// Result of generating C header file via cbindgen as well as the Dart derived from it.
/// The header file is written as a side effect. For Flutter it is placed inside the `ios/Classes`
/// folder where it is needed, for Dart it is placed alongside the generated dart for now.
/// The generated Dart and the path to where it should be placed is included as well.
#[derive(Debug)]
struct GenerateResult {
    /// Content of Dart generated and to be included by the Dart or Flutter app.
    generated_dart: String,

    /// Path at which the Dart/Flutter app expects the generated Dart code to be and from which the
    /// generated code imports the darg ffigen generated bindings.
    /// This file still needs to be written.
    generated_dart_path: String,

    /// Path at which the C headers file was ALREADY written. This may be ignored for Dart apps,
    /// but should be located in the correct location for Flutter apps.
    generated_bindings_h_path: String,
}

fn generate(
    BuildConfig {
        project_root,
        workspace_root,
        lib_name,
        crate_name,
        project,
        target,
    }: &BuildConfig,
) -> Result<GenerateResult> {
    let bindings_generator = BindingsGenerator {
        crate_name,
        crate_dir: project_root,
        cargo: "cargo",
    };
    let target_crate_root = Path::new(workspace_root.unwrap_or(project_root));
    let project_root = Path::new(project_root);
    log::info!("Generating bindings");

    let bindings_h = bindings_generator.generate()?;
    let bindings_h_paths = project.paths_to_generated_c_bindings(project_root);

    // TODO: cbindgen unwraps all over the place here, so we should ensure that we can
    // access the file we're writing to
    // NOTE: as a side effect we write the binding.h file here already, it goes unused for Dart,
    // but is essential for Flutter ios apps.
    for bindings_h_path in &bindings_h_paths {
        bindings_h.write_to_file(&bindings_h_path);
    }
    let bindings_h_path = &bindings_h_paths[0];
    let bindings_h_content = fs::read_to_string(&bindings_h_path)?;

    // NOTE: this is generated by dart ffigen step which we don't corrently control
    let ffigen_generated_path = project.path_to_generated_ffigen(project_root);
    let generated_dart_path = project.path_to_generated_rid(project_root);

    // TODO: determine this as relative path from  'generated_dart_path' -> 'ffigen_generated_path'
    let ffigen_binding = &format!(
        "./{}",
        ffigen_generated_path.file_name().unwrap().to_string_lossy()
    );
    let path_to_target =
        &format!("{}", project.path_to_target(target_crate_root).display());

    let code_sections = CodeSections::new(&bindings_h_content);
    let dart_generator = DartGenerator {
        lib_name,
        target,
        ffigen_binding,
        path_to_target,
        code_sections: &code_sections,
        project: &project,
    };

    log::info!("Generating dart");
    let generated_dart = dart_generator.generate();

    Ok(GenerateResult {
        generated_dart,
        generated_dart_path: format!("{}", generated_dart_path.display()),
        generated_bindings_h_path: format!("{}", bindings_h_path.display()),
    })
}

pub fn build(build_config: &BuildConfig) -> Result<()> {
    log::init();

    let GenerateResult {
        generated_dart,
        generated_dart_path,
        ..
    } = generate(build_config)?;

    // NOTE: the directory to hold the file is recursively created if it doesn't exist yet
    fs::write(generated_dart_path, generated_dart)?;

    Ok(())
}

// TODO: disabled due to getting stuck
#[cfg(test_disabled)]
mod tests {
    use super::*;

    #[test]
    fn generate_test() {
        let build_config = BuildConfig {
            project_root: "fixtures/foo-bar-baz",
            workspace_root: None,
            project: Project::Dart,
            lib_name: "libfoo_bar_baz",
            crate_name: "foo_bar_baz",
            target: BuildTarget::Debug,
        };
        let result = generate(&build_config);
        match result {
            Err(err) => assert!(false, "generate should not error {}", err),
            Ok(result) => println!("{:#?}", result),
        };
    }
}
